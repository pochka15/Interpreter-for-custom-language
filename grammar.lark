_comma_separated{arg}: arg ("," arg)*

_parenthesized{arg}: "(" arg ")"

start: ((statement | declaration) (_NL (statement | declaration))*)?

?identifier: NAME

function_declaration: "/f" NAME function_parameters FUNCTION_RETURN_TYPE? "{" statements_block "}"

function_parameters: "(" _comma_separated{function_parameter}? ")"

function_parameter: NAME type

type: _parenthesized{type} | simple_type ("." simple_type)*

?simple_type: NAME

?statement: assignment | for_statement | while_statement | expression | jump_statement

?declaration: class_declaration | function_declaration

parents: _comma_separated{NAME}

property_declaration: var_or_const? NAME type 

property_assignment: var_or_const? NAME type? ASSIGNMENT_OPERATOR expression

variable_declaration: var_or_const NAME type

?var_or_const: "/v" | "/c"

?class_declaration: "class" NAME parents? "{" class_body "}"

class_body: (member_declaration (_NL member_declaration)*)?

member_declaration: function_declaration | property_declaration | property_assignment

statements_block: (statement (_NL statement+)*)?

assignment: directly_assignable_expression ASSIGNMENT_OPERATOR expression
  | assignable_expression ASSIGNMENT_AND_OPERATOR expression

?assignable_expression: prefix_unary_expression | _parenthesized{prefix_unary_expression}

?directly_assignable_expression : postfix_unary_expression assignable_suffix?
  | variable_declaration
  | _parenthesized{directly_assignable_expression}

?assignable_suffix: indexing_suffix
  | navigation_suffix

for_statement: "for" label? NAME "in" expression "{" statements_block "}"

while_statement: "while" label? expression "{" statements_block "}"

label: NAME "@"

?expression: disjunction

?disjunction: conjunction ("||" conjunction)*

?conjunction: equality ("&&" equality)*

?equality: comparison (EQUALITY_OPERATOR comparison)*

?comparison: additive_expression (COMPARISON_OPERATOR additive_expression)*

function_call_arguments: (expression ("," expression)*)?

?additive_expression: multiplicative_expression (ADDITIVE_OPERATOR multiplicative_expression)*

?multiplicative_expression: prefix_unary_expression (MULTIPLICATIVE_OPERATOR prefix_unary_expression)*

?prefix_unary_expression: PREFIX_OPERATOR* postfix_unary_expression

?postfix_unary_expression: primary_expression postfix_unary_suffix*

?postfix_unary_suffix: call_suffix | indexing_suffix | navigation_suffix

call_suffix: "(" function_call_arguments ")"

indexing_suffix: "[" expression "]"

navigation_suffix: "." NAME

?primary_expression: _parenthesized{expression}
  | identifier
  | simple_literal
  | collection_literal
  | if_expression

collection_literal: "[" expression ("," expression)* "]" | "[" "]"

jump_statement: RETURN expression?
  | CONTINUE
  | continue_at
  | BREAK
  | break_at

continue_at: _CONTINUE_AT NAME

break_at: _BREAK_AT NAME

if_expression: "if" expression "{" statements_block "}"
  | "if" expression "{" statements_block "}" ELSE "{" statements_block "}"
  | "if" expression "{" statements_block "}" ELSE if_expression

?simple_literal: STRING | BOOLEAN | DEC_NUMBER | FLOAT_NUMBER

%import python.DEC_NUMBER
%import python.COMMENT
%import python.STRING
%import common.LETTER
%import common.DIGIT
%import common.WS
%import common.NEWLINE -> _NL

%ignore WS
%ignore COMMENT

// Non-terminals
EQUALITY_OPERATOR: "!=" | "=="
ASSIGNMENT_OPERATOR: "="
BOOLEAN: "true" | "false"
FLOAT_NUMBER: /((\d+\.[\d_]*|\.[\d_]+)(e[-+]?\d+)?|\d+(e[-+]?\d+))/i
FUNCTION_RETURN_TYPE: NAME
COMPARISON_OPERATOR:  "<" | ">" | "<=" | ">="
ADDITIVE_OPERATOR: "+" | "-"
PREFIX_OPERATOR: ADDITIVE_OPERATOR | "!"
MULTIPLICATIVE_OPERATOR: "*" | "//" | "%"
ASSIGNMENT_AND_OPERATOR: "+=" | "-=" | "*=" | "//=" | "%="
RELATIVE_LOCATION: /\.+/
RETURN: "ret"
CONTINUE: "continue"
BREAK: "break"
_CONTINUE_AT: "continue@"
_BREAK_AT: "break@"
ELSE: "else"
NAME: /(?!(class|true|false|ret|continue|break|else|this|in)\b)[a-zA-Z_][a-zA-Z_0-9]*/