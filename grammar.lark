start: import_statement* ((statement | declaration) (_NL (statement | declaration))*)?

import_statement: import_name | import_from

import_name: IMPORT as_name ("," as_name)*

import_from: FROM (RELATIVE_LOCATION)? (NAME ((".") NAME)*)? IMPORT import_targets

?import_targets: as_name ("," as_name)* | IMPORT_ALL

?as_name: NAME ("as" NAME)?

?identifier: NAME ("." NAME)*

function_declaration: NAME type_arguments? function_parameters FUNCTION_VISIBILITY_MODIFIER? (OVERRIDDEN)? FUNCTION_RETURN_TYPE? "{" statements_block "}"

abstract_function_declaration: NAME type_arguments? function_parameters FUNCTION_VISIBILITY_MODIFIER? (ABSTRACT)? FUNCTION_RETURN_TYPE

type_arguments: ("<" type ("," type)* ">")

function_parameters: "(" (NAME type ("," NAME type)*)? ")"

type: "(" type ")" | simple_user_type ("." simple_user_type)*

simple_user_type: NAME type_arguments?

statement: assignment | for_statement | while_statement | expression | jump_statement

declaration: interface_declaration | class_declaration | function_declaration

interface_declaration: NAME "interface" type_arguments? parent_interfaces "{" interface_body "}"

parent_interfaces: (NAME ("," NAME)*)?

interface_body: interface_function_declaration+

interface_function_declaration: (function_declaration | function_declaration_without_body)

function_declaration_without_body: NAME type_arguments? function_parameters FUNCTION_RETURN_TYPE

property_declaration: NAME type? PROPERTY_VISIBILITY_MODIFIER? (VAL | VAR)? ("=" expression)?

variable_declaration: NAME type? (VAL | VAR)?

class_declaration: NAME "class" type_arguments? ABSTRACT? class_hint "{" class_body "}"

// which class it inherits and which interfaces are implemented
class_hint: (NAME ("," NAME)*)?

class_body: (class_member_declaration (_NL class_member_declaration)*)?

class_member_declaration: function_declaration | property_declaration | abstract_function_declaration

statements_block: (statement (_NL statement+)*)?

assignment: directly_assignable_expression "=" expression
  | assignable_expression ASSIGNMENT_AND_OPERATOR expression

assignable_expression: prefix_unary_expression | "(" prefix_unary_expression ")"

directly_assignable_expression : postfix_unary_expression assignable_suffix
  | variable_declaration
  | "(" directly_assignable_expression ")"

assignable_suffix: type_arguments
  | indexing_suffix
  | navigation_suffix

for_statement: label? "for" NAME "in" expression "{" statements_block "}"

while_statement: label? "while" expression "{" statements_block "}"

label: NAME "@"

?expression: disjunction

disjunction: conjunction ("||" conjunction)*

conjunction: equality ("&&" equality)*

equality: comparison (EQUALITY_OPERATOR comparison)*

comparison: additive_expression (COMPARISON_OPERATOR additive_expression)*

function_call_arguments: (expression ("," expression)*)?

additive_expression: multiplicative_expression (ADDITIVE_OPERATOR multiplicative_expression)*

multiplicative_expression: prefix_unary_expression (MULTIPLICATIVE_OPERATOR prefix_unary_expression)*

prefix_unary_expression: PREFIX_OPERATOR* postfix_unary_expression

postfix_unary_expression: primary_expression postfix_unary_suffix*

postfix_unary_suffix: type_arguments | call_suffix | indexing_suffix | navigation_suffix

call_suffix: type_arguments? "(" function_call_arguments ")"

indexing_suffix: "[" expression ("," expression)*"]"

navigation_suffix: "." NAME

primary_expression: "(" expression ")"
  | identifier
  | simple_literal
  | collection_literal
  | if_expression

collection_literal: "[" expression ("," expression)* "]" | "[" "]"


jump_statement: RETURN expression?
  | CONTINUE
  | continue_at
  | BREAK
  | break_at

continue_at: CONTINUE_AT NAME

break_at: BREAK_AT NAME

if_expression: "if" expression "{" statements_block "}"
  | "if" expression "{" statements_block "}" ELSE "{" statements_block "}"
  | "if" expression "{" statements_block "}" ELSE if_expression

?assignment_hint: "(" NAME [CONSTANT_MODIFIER] ")"

simple_literal: STRING | BOOLEAN | NUMBER | FLOAT_NUMBER

// Non-terminals
CONSTANT_MODIFIER: "const"
EQUALITY_OPERATOR: "!=" | "=="
BOOLEAN: "true" | "false"
FLOAT_NUMBER: /((\d+\.[\d_]*|\.[\d_]+)(e[-+]?\d+)?|\d+(e[-+]?\d+))/i
_INDENTATION: / {4}/ // 4 whitespaces
FUNCTION_VISIBILITY_MODIFIER: "private" | "public"
FUNCTION_RETURN_TYPE: NAME
PROPERTY_VISIBILITY_MODIFIER: "public" | "private"
COMPARISON_OPERATOR:  "<" | ">" | "<=" | ">="
ADDITIVE_OPERATOR: "+" | "-"
PREFIX_OPERATOR: ADDITIVE_OPERATOR | "!"
MULTIPLICATIVE_OPERATOR: "*" | "/" | "%"
IMPORT: "import"
ASSIGNMENT_AND_OPERATOR: "+=" | "-=" | "*=" | "/=" | "%="
FROM: "from"
RELATIVE_LOCATION: /\.+/
IMPORT_ALL: "*"
VAL: "val"
VAR: "var"
ABSTRACT: "abstract"
OVERRIDDEN: "overridden"
RETURN: "return"
CONTINUE: "continue"
BREAK: "break"
CONTINUE_AT: "continue@"
BREAK_AT: "break@"
ELSE: "else"


%import python.DEC_NUMBER -> NUMBER
%import python.COMMENT
%import python.STRING
%import common.CNAME -> NAME
%import common.WS
%import common.NEWLINE -> _NL

%ignore WS
%ignore COMMENT