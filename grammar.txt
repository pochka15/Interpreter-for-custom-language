start: (function_declaration (NEWLINE function_declaration)*)?

function_declaration: NAME function_parameters FUNCTION_RETURN_TYPE? "{" statements_block "}"

function_parameters: "(" (function_parameter ("," function_parameter)*)? ")"

function_parameter: NAME type

type: "(" type ")" | simple_type ("." simple_type)*

// Inline
simple_type: NAME

// Inline
statement: assignment | for_statement | while_statement | expression | jump_statement

variable_declaration: (VAR | CONST) NAME type

statements_block: (statement (NEWLINE statement+)*)?

assignment: directly_assignable_expression ASSIGNMENT_OPERATOR expression
  | assignable_expression ASSIGNMENT_AND_OPERATOR expression

// Inline
assignable_expression: prefix_unary_expression 
  | "(" prefix_unary_expression ")"

// Inline
directly_assignable_expression : postfix_unary_expression assignable_suffix?
  | variable_declaration
  | "(" directly_assignable_expression ")"

// Inline
assignable_suffix: indexing_suffix
  | navigation_suffix

for_statement: "for" NAME "in" expression "{" statements_block "}"

while_statement: "while" expression "{" statements_block "}"

// Inline
expression: disjunction

// Inline
disjunction: conjunction ("||" conjunction)*

// Inline
conjunction: equality ("&&" equality)*

// Inline
equality: comparison (EQUALITY_OPERATOR comparison)*

// Inline
comparison: additive_expression (COMPARISON_OPERATOR additive_expression)*

function_call_arguments: (expression ("," expression)*)?

// Inline
additive_expression: multiplicative_expression (ADDITIVE_OPERATOR multiplicative_expression)*

// Inline
multiplicative_expression: prefix_unary_expression (MULTIPLICATIVE_OPERATOR prefix_unary_expression)*

// Inline
prefix_unary_expression: PREFIX_OPERATOR* postfix_unary_expression

// Inline
postfix_unary_expression: primary_expression postfix_unary_suffix*

// Inline
postfix_unary_suffix: call_suffix | indexing_suffix | navigation_suffix

call_suffix: "(" function_call_arguments ")"

indexing_suffix: "[" expression "]"

navigation_suffix: "." NAME

// Inline
primary_expression: "(" expression ")"
  | identifier
  | simple_literal
  | collection_literal
  | if_expression

// Inline
identifier: NAME

collection_literal: "[" expression ("," expression)* "]" | "[" "]"

jump_statement: RETURN expression?
  | BREAK

if_expression: "if" expression "{" statements_block "}"
  | "if" expression "{" statements_block "}" ELSE "{" statements_block "}"
  | "if" expression "{" statements_block "}" ELSE if_expression

// Inline
simple_literal: STRING | BOOLEAN | DEC_NUMBER | FLOAT_NUMBER

DEC_NUMBER: /0|[1-9][\d_]*/i
COMMENT: /#[^\n]*/
STRING : /[ubf]?r?("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
DIGIT: "0".."9"

//
// Names (Variables)
//
LCASE_LETTER: "a".."z"
UCASE_LETTER: "A".."Z"
LETTER: UCASE_LETTER | LCASE_LETTER
//
// Whitespace
//
WS: /[ \t\f\r\n]/+
CR : /\r/
LF : /\n/
NEWLINE: (CR? LF)+

// Non-terminals
EQUALITY_OPERATOR: "!=" | "=="
ASSIGNMENT_OPERATOR: "="
BOOLEAN: "true" | "false"
FLOAT_NUMBER: /((\d+\.[\d_]*|\.[\d_]+)(e[-+]?\d+)?|\d+(e[-+]?\d+))/i
FUNCTION_RETURN_TYPE: NAME
COMPARISON_OPERATOR:  "<" | ">" | "<=" | ">="
ADDITIVE_OPERATOR: "+" | "-"
PREFIX_OPERATOR: ADDITIVE_OPERATOR | "!"
MULTIPLICATIVE_OPERATOR: "*" | "/" | "%"
ASSIGNMENT_AND_OPERATOR: "+=" | "-=" | "*=" | "/=" | "%="
RELATIVE_LOCATION: /\.+/
RETURN: "ret"
BREAK: "break"
ELSE: "else"
CONST: "c"
VAR: "v"
NAME: /(?!(for|while|true|false|ret|break|else|in|v|c)\b)[a-zA-Z_][a-zA-Z_0-9]*/